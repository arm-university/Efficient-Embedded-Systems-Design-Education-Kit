; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_i2c.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_i2c.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I.\drivers -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\ARM\CMSIS\5.8.0\CMSIS\Core\Include -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=534 -D_RTE_ -DSTM32F401xE -D_RTE_ --omf_browse=.\objects\stm32f4xx_i2c.crf drivers\stm32f4xx_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;650      */
;;;651    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;652    {
;;;653      /* Check the parameters */
;;;654      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;655      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;656      if (NewState != DISABLE)
;;;657      {
;;;658        /* Enable the selected I2C ARP */
;;;659        I2Cx->CR1 |= I2C_CR1_ENARP;
;;;660      }
;;;661      else
;;;662      {
;;;663        /* Disable the selected I2C ARP */
;;;664        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L1.12|
000006  f0410110          ORR      r1,r1,#0x10           ;659
00000a  e002              B        |L1.18|
                  |L1.12|
00000c  f64f72ef          MOV      r2,#0xffef
000010  4011              ANDS     r1,r1,r2
                  |L1.18|
000012  6001              STR      r1,[r0,#0]            ;659
;;;665      }
;;;666    }
000014  4770              BX       lr
;;;667    /**
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;410      */
;;;411    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;412    {
;;;413      /* Check the parameters */
;;;414      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;415      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;416      if (NewState != DISABLE)
;;;417      {
;;;418        /* Enable the acknowledgement */
;;;419        I2Cx->CR1 |= I2C_CR1_ACK;
;;;420      }
;;;421      else
;;;422      {
;;;423        /* Disable the acknowledgement */
;;;424        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L2.12|
000006  f4416180          ORR      r1,r1,#0x400          ;419
00000a  e002              B        |L2.18|
                  |L2.12|
00000c  f64f32ff          MOV      r2,#0xfbff
000010  4011              ANDS     r1,r1,r2
                  |L2.18|
000012  6001              STR      r1,[r0,#0]            ;419
;;;425      }
;;;426    }
000014  4770              BX       lr
;;;427    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;787      */
;;;788    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;789    {
;;;790      /* Check the parameters */
;;;791      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;792      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;793      if (NewState != DISABLE)
;;;794      {
;;;795        /* Enable the selected I2C PEC calculation */
;;;796        I2Cx->CR1 |= I2C_CR1_ENPEC;
;;;797      }
;;;798      else
;;;799      {
;;;800        /* Disable the selected I2C PEC calculation */
;;;801        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  f0410120          ORR      r1,r1,#0x20           ;796
00000a  e002              B        |L3.18|
                  |L3.12|
00000c  f64f72df          MOV      r2,#0xffdf
000010  4011              ANDS     r1,r1,r2
                  |L3.18|
000012  6001              STR      r1,[r0,#0]            ;796
;;;802      }
;;;803    }
000014  4770              BX       lr
;;;804    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;1090     */
;;;1091   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  4602              MOV      r2,r0
;;;1092   {
;;;1093     uint32_t lastevent = 0;
;;;1094     uint32_t flag1 = 0, flag2 = 0;
;;;1095     ErrorStatus status = ERROR;
000002  2001              MOVS     r0,#1
;;;1096   
;;;1097     /* Check the parameters */
;;;1098     //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1099     //assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;1100   
;;;1101     /* Read the I2Cx status register */
;;;1102     flag1 = I2Cx->SR1;
000004  6953              LDR      r3,[r2,#0x14]
;;;1103     flag2 = I2Cx->SR2;
000006  6992              LDR      r2,[r2,#0x18]
;;;1104     flag2 = flag2 << 16;
;;;1105   
;;;1106     /* Get the last event value from I2C status register */
;;;1107     lastevent = (flag1 | flag2) & FLAG_MASK;
000008  ea434302          ORR      r3,r3,r2,LSL #16
00000c  f023427f          BIC      r2,r3,#0xff000000
;;;1108   
;;;1109     /* Check whether the last event contains the I2C_EVENT */
;;;1110     if ((lastevent & I2C_EVENT) == I2C_EVENT)
000010  4391              BICS     r1,r1,r2
000012  d100              BNE      |L4.22|
;;;1111     {
;;;1112       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1113       status = SUCCESS;
000014  2000              MOVS     r0,#0
                  |L4.22|
;;;1114     }
;;;1115     else
;;;1116     {
;;;1117       /* ERROR: last event is different from I2C_EVENT */
;;;1118       status = ERROR;
;;;1119     }
;;;1120     /* Return status */
;;;1121     return status;
;;;1122   }
000016  4770              BX       lr
;;;1123   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1270     */
;;;1271   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  43c9              MVNS     r1,r1
;;;1272   {
;;;1273     uint32_t flagpos = 0;
;;;1274     /* Check the parameters */
;;;1275     //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1276     //assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1277     /* Get the I2C flag position */
;;;1278     flagpos = I2C_FLAG & FLAG_MASK;
;;;1279     /* Clear the selected I2C flag */
;;;1280     I2Cx->SR1 = (uint16_t)~flagpos;
000002  b289              UXTH     r1,r1
000004  6141              STR      r1,[r0,#0x14]
;;;1281   }
000006  4770              BX       lr
;;;1282   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1364     */
;;;1365   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  43c9              MVNS     r1,r1
;;;1366   {
;;;1367     uint32_t flagpos = 0;
;;;1368     /* Check the parameters */
;;;1369     //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1370     //assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1371   
;;;1372     /* Get the I2C flag position */
;;;1373     flagpos = I2C_IT & FLAG_MASK;
;;;1374   
;;;1375     /* Clear the selected I2C flag */
;;;1376     I2Cx->SR1 = (uint16_t)~flagpos;
000002  b289              UXTH     r1,r1
000004  6141              STR      r1,[r0,#0x14]
;;;1377   }
000006  4770              BX       lr
;;;1378   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;307      */
;;;308    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;309    {
;;;310      /* Check the parameters */
;;;311      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;312      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;313      if (NewState != DISABLE)
;;;314      {
;;;315        /* Enable the selected I2C peripheral */
;;;316        I2Cx->CR1 |= I2C_CR1_PE;
;;;317      }
;;;318      else
;;;319      {
;;;320        /* Disable the selected I2C peripheral */
;;;321        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L7.12|
000006  f0410101          ORR      r1,r1,#1              ;316
00000a  e002              B        |L7.18|
                  |L7.12|
00000c  f64f72fe          MOV      r2,#0xfffe
000010  4011              ANDS     r1,r1,r2
                  |L7.18|
000012  6001              STR      r1,[r0,#0]            ;316
;;;322      }
;;;323    }
000014  4770              BX       lr
;;;324    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;842      */
;;;843    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;844    {
;;;845      /* Check the parameters */
;;;846      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;847      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;848      if (NewState != DISABLE)
;;;849      {
;;;850        /* Enable the selected I2C DMA requests */
;;;851        I2Cx->CR2 |= I2C_CR2_DMAEN;
;;;852      }
;;;853      else
;;;854      {
;;;855        /* Disable the selected I2C DMA requests */
;;;856        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L8.12|
000006  f4416100          ORR      r1,r1,#0x800          ;851
00000a  e002              B        |L8.18|
                  |L8.12|
00000c  f24f72ff          MOV      r2,#0xf7ff
000010  4011              ANDS     r1,r1,r2
                  |L8.18|
000012  6041              STR      r1,[r0,#4]            ;851
;;;857      }
;;;858    }
000014  4770              BX       lr
;;;859    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;866      */
;;;867    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;868    {
;;;869      /* Check the parameters */
;;;870      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;871      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;872      if (NewState != DISABLE)
;;;873      {
;;;874        /* Next DMA transfer is the last transfer */
;;;875        I2Cx->CR2 |= I2C_CR2_LAST;
;;;876      }
;;;877      else
;;;878      {
;;;879        /* Next DMA transfer is not the last transfer */
;;;880        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L9.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;875
00000a  e002              B        |L9.18|
                  |L9.12|
00000c  f64e72ff          MOV      r2,#0xefff
000010  4011              ANDS     r1,r1,r2
                  |L9.18|
000012  6041              STR      r1,[r0,#4]            ;875
;;;881      }
;;;882    }
000014  4770              BX       lr
;;;883    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;131      */
;;;132    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  490d              LDR      r1,|L10.56|
;;;133    {
000002  b510              PUSH     {r4,lr}
;;;134      /* Check the parameters */
;;;135      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;136    
;;;137      if (I2Cx == I2C1)
000004  4288              CMP      r0,r1
000006  d102              BNE      |L10.14|
;;;138      {
;;;139        /* Enable I2C1 reset state */
;;;140        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  054c              LSLS     r4,r1,#21
;;;141        /* Release I2C1 from reset state */
;;;142        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
00000c  e00a              B        |L10.36|
                  |L10.14|
;;;143      }
;;;144      else if (I2Cx == I2C2)
00000e  490b              LDR      r1,|L10.60|
000010  4288              CMP      r0,r1
000012  d102              BNE      |L10.26|
;;;145      {
;;;146        /* Enable I2C2 reset state */
;;;147        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000014  2101              MOVS     r1,#1
000016  058c              LSLS     r4,r1,#22
;;;148        /* Release I2C2 from reset state */
;;;149        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
000018  e004              B        |L10.36|
                  |L10.26|
;;;150      }
;;;151      else 
;;;152      {
;;;153        if (I2Cx == I2C3)
00001a  4909              LDR      r1,|L10.64|
00001c  4288              CMP      r0,r1
00001e  d10a              BNE      |L10.54|
;;;154        {
;;;155          /* Enable I2C3 reset state */
;;;156          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
000020  2101              MOVS     r1,#1
000022  05cc              LSLS     r4,r1,#23
                  |L10.36|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;157          /* Release I2C3 from reset state */
;;;158          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
00002a  4620              MOV      r0,r4
00002c  e8bd4010          POP      {r4,lr}
000030  2100              MOVS     r1,#0
000032  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L10.54|
;;;159        }
;;;160      }
;;;161    }
000036  bd10              POP      {r4,pc}
;;;162    
                          ENDP

                  |L10.56|
                          DCD      0x40005400
                  |L10.60|
                          DCD      0x40005800
                  |L10.64|
                          DCD      0x40005c00

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;460      */
;;;461    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;462    {
;;;463      /* Check the parameters */
;;;464      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;465      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;466      if (NewState != DISABLE)
;;;467      {
;;;468        /* Enable dual addressing mode */
;;;469        I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
;;;470      }
;;;471      else
;;;472      {
;;;473        /* Disable dual addressing mode */
;;;474        I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
000002  68c1              LDR      r1,[r0,#0xc]
000004  d002              BEQ      |L11.12|
000006  f0410101          ORR      r1,r1,#1              ;469
00000a  e002              B        |L11.18|
                  |L11.12|
00000c  f64f72fe          MOV      r2,#0xfffe
000010  4011              ANDS     r1,r1,r2
                  |L11.18|
000012  60c1              STR      r1,[r0,#0xc]          ;469
;;;475      }
;;;476    }
000014  4770              BX       lr
;;;477    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;560      */
;;;561    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;562    {
;;;563      /* Check the parameters */
;;;564      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;565      //assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;566      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
;;;567      {
;;;568        /* I2C fast mode Tlow/Thigh=2 */
;;;569        I2Cx->CCR &= I2C_DutyCycle_2;
;;;570      }
;;;571      else
;;;572      {
;;;573        /* I2C fast mode Tlow/Thigh=16/9 */
;;;574        I2Cx->CCR |= I2C_DutyCycle_16_9;
000004  69c1              LDR      r1,[r0,#0x1c]
000006  d003              BEQ      |L12.16|
000008  f64b72ff          MOV      r2,#0xbfff            ;569
00000c  4011              ANDS     r1,r1,r2              ;569
00000e  e001              B        |L12.20|
                  |L12.16|
000010  f4414180          ORR      r1,r1,#0x4000
                  |L12.20|
000014  61c1              STR      r1,[r0,#0x1c]         ;569
;;;575      }
;;;576    }
000016  4770              BX       lr
;;;577    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;484      */
;;;485    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;486    {
;;;487      /* Check the parameters */
;;;488      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;489      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;490      if (NewState != DISABLE)
;;;491      {
;;;492        /* Enable generall call */
;;;493        I2Cx->CR1 |= I2C_CR1_ENGC;
;;;494      }
;;;495      else
;;;496      {
;;;497        /* Disable generall call */
;;;498        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L13.12|
000006  f0410140          ORR      r1,r1,#0x40           ;493
00000a  e002              B        |L13.18|
                  |L13.12|
00000c  f64f72bf          MOV      r2,#0xffbf
000010  4011              ANDS     r1,r1,r2
                  |L13.18|
000012  6001              STR      r1,[r0,#0]            ;493
;;;499      }
;;;500    }
000014  4770              BX       lr
;;;501    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;331      */
;;;332    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;333    {
;;;334      /* Check the parameters */
;;;335      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;336      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;337      if (NewState != DISABLE)
;;;338      {
;;;339        /* Generate a START condition */
;;;340        I2Cx->CR1 |= I2C_CR1_START;
;;;341      }
;;;342      else
;;;343      {
;;;344        /* Disable the START condition generation */
;;;345        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L14.12|
000006  f4417180          ORR      r1,r1,#0x100          ;340
00000a  e002              B        |L14.18|
                  |L14.12|
00000c  f64f62ff          MOV      r2,#0xfeff
000010  4011              ANDS     r1,r1,r2
                  |L14.18|
000012  6001              STR      r1,[r0,#0]            ;340
;;;346      }
;;;347    }
000014  4770              BX       lr
;;;348    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;355      */
;;;356    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;357    {
;;;358      /* Check the parameters */
;;;359      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;360      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;361      if (NewState != DISABLE)
;;;362      {
;;;363        /* Generate a STOP condition */
;;;364        I2Cx->CR1 |= I2C_CR1_STOP;
;;;365      }
;;;366      else
;;;367      {
;;;368        /* Disable the STOP condition generation */
;;;369        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L15.12|
000006  f4417100          ORR      r1,r1,#0x200          ;364
00000a  e002              B        |L15.18|
                  |L15.12|
00000c  f64f52ff          MOV      r2,#0xfdff
000010  4011              ANDS     r1,r1,r2
                  |L15.18|
000012  6001              STR      r1,[r0,#0]            ;364
;;;370      }
;;;371    }
000014  4770              BX       lr
;;;372    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1193     */
;;;1194   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b50c              PUSH     {r2,r3,lr}
;;;1195   {
000002  4602              MOV      r2,r0
;;;1196     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1197     __IO uint32_t i2creg = 0, i2cxbase = 0;
;;;1198   
;;;1199     /* Check the parameters */
;;;1200     //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1201     //assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1202   
;;;1203     /* Get the I2Cx peripheral base address */
;;;1204     i2cxbase = (uint32_t)I2Cx;
;;;1205     
;;;1206     /* Read flag register index */
;;;1207     i2creg = I2C_FLAG >> 28;
000006  9200              STR      r2,[sp,#0]
000008  0f0a              LSRS     r2,r1,#28
;;;1208     
;;;1209     /* Get bit[23:0] of the flag */
;;;1210     I2C_FLAG &= FLAG_MASK;
00000a  f021417f          BIC      r1,r1,#0xff000000
00000e  9201              STR      r2,[sp,#4]            ;1195
000010  d002              BEQ      |L16.24|
;;;1211     
;;;1212     if(i2creg != 0)
;;;1213     {
;;;1214       /* Get the I2Cx SR1 register address */
;;;1215       i2cxbase += 0x14;
000012  9a00              LDR      r2,[sp,#0]
000014  3214              ADDS     r2,r2,#0x14
000016  e002              B        |L16.30|
                  |L16.24|
;;;1216     }
;;;1217     else
;;;1218     {
;;;1219       /* Flag in I2Cx SR2 Register */
;;;1220       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
;;;1221       /* Get the I2Cx SR2 register address */
;;;1222       i2cxbase += 0x18;
000018  9a00              LDR      r2,[sp,#0]
00001a  0c09              LSRS     r1,r1,#16             ;1220
00001c  3218              ADDS     r2,r2,#0x18
                  |L16.30|
;;;1223     }
;;;1224     
;;;1225     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
00001e  9200              STR      r2,[sp,#0]
000020  6812              LDR      r2,[r2,#0]
000022  420a              TST      r2,r1
000024  d000              BEQ      |L16.40|
;;;1226     {
;;;1227       /* I2C_FLAG is set */
;;;1228       bitstatus = SET;
000026  2001              MOVS     r0,#1
                  |L16.40|
;;;1229     }
;;;1230     else
;;;1231     {
;;;1232       /* I2C_FLAG is reset */
;;;1233       bitstatus = RESET;
;;;1234     }
;;;1235     
;;;1236     /* Return the I2C_FLAG status */
;;;1237     return  bitstatus;
;;;1238   }
000028  bd0c              POP      {r2,r3,pc}
;;;1239   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1304     */
;;;1305   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b510              PUSH     {r4,lr}
;;;1306   {
000002  4603              MOV      r3,r0
;;;1307     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1308     uint32_t enablestatus = 0;
;;;1309   
;;;1310     /* Check the parameters */
;;;1311     //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1312     //assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1313   
;;;1314     /* Check if the interrupt source is enabled or not */
;;;1315     enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
000006  685a              LDR      r2,[r3,#4]
000008  f44f64e0          MOV      r4,#0x700
00000c  ea044411          AND      r4,r4,r1,LSR #16
;;;1316     
;;;1317     /* Get bit[23:0] of the flag */
;;;1318     I2C_IT &= FLAG_MASK;
;;;1319   
;;;1320     /* Check the status of the specified I2C flag */
;;;1321     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
000010  695b              LDR      r3,[r3,#0x14]
000012  4022              ANDS     r2,r2,r4              ;1315
000014  f021417f          BIC      r1,r1,#0xff000000     ;1318
000018  420b              TST      r3,r1
00001a  d002              BEQ      |L17.34|
00001c  2a00              CMP      r2,#0
00001e  d000              BEQ      |L17.34|
;;;1322     {
;;;1323       /* I2C_IT is set */
;;;1324       bitstatus = SET;
000020  2001              MOVS     r0,#1
                  |L17.34|
;;;1325     }
;;;1326     else
;;;1327     {
;;;1328       /* I2C_IT is reset */
;;;1329       bitstatus = RESET;
;;;1330     }
;;;1331     /* Return the I2C_IT status */
;;;1332     return  bitstatus;
;;;1333   }
000022  bd10              POP      {r4,pc}
;;;1334   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;1138     */
;;;1139   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  6941              LDR      r1,[r0,#0x14]
;;;1140   {
;;;1141     uint32_t lastevent = 0;
;;;1142     uint32_t flag1 = 0, flag2 = 0;
;;;1143   
;;;1144     /* Check the parameters */
;;;1145     //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1146   
;;;1147     /* Read the I2Cx status register */
;;;1148     flag1 = I2Cx->SR1;
;;;1149     flag2 = I2Cx->SR2;
000002  6980              LDR      r0,[r0,#0x18]
;;;1150     flag2 = flag2 << 16;
;;;1151   
;;;1152     /* Get the last event value from I2C status register */
;;;1153     lastevent = (flag1 | flag2) & FLAG_MASK;
000004  ea414100          ORR      r1,r1,r0,LSL #16
000008  f021407f          BIC      r0,r1,#0xff000000
;;;1154   
;;;1155     /* Return status */
;;;1156     return lastevent;
;;;1157   }
00000c  4770              BX       lr
;;;1158   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;809      */
;;;810    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  6980              LDR      r0,[r0,#0x18]
;;;811    {
;;;812      /* Check the parameters */
;;;813      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;814      /* Return the selected I2C PEC value */
;;;815      return ((I2Cx->SR2) >> 8);
000002  f3c02007          UBFX     r0,r0,#8,#8
;;;816    }
000006  4770              BX       lr
;;;817    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;1031     */
;;;1032   void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1033   {
;;;1034     /* Check the parameters */
;;;1035     //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1036     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1037     //assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;1038     
;;;1039     if (NewState != DISABLE)
;;;1040     {
;;;1041       /* Enable the selected I2C interrupts */
;;;1042       I2Cx->CR2 |= I2C_IT;
;;;1043     }
;;;1044     else
;;;1045     {
;;;1046       /* Disable the selected I2C interrupts */
;;;1047       I2Cx->CR2 &= (uint16_t)~I2C_IT;
000002  6842              LDR      r2,[r0,#4]
000004  d001              BEQ      |L20.10|
000006  430a              ORRS     r2,r2,r1              ;1042
000008  e002              B        |L20.16|
                  |L20.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L20.16|
000010  6042              STR      r2,[r0,#4]            ;1042
;;;1048     }
;;;1049   }
000012  4770              BX       lr
;;;1050   
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;174      */
;;;175    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  b57f              PUSH     {r0-r6,lr}
;;;176    {
000002  4604              MOV      r4,r0
;;;177      uint16_t tmpreg = 0, freqrange = 0;
;;;178      uint16_t result = 0x04;
;;;179      uint32_t pclk1 = 8000000;
;;;180      RCC_ClocksTypeDef  rcc_clocks;
;;;181      /* Check the parameters */
;;;182      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;183      //assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;184      //assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;185      //assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;186      //assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;187      //assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;188      //assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;189    
;;;190    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;191      /* Get the I2Cx CR2 value */
;;;192      tmpreg = I2Cx->CR2;
000004  6840              LDR      r0,[r0,#4]
000006  460d              MOV      r5,r1                 ;176
000008  b280              UXTH     r0,r0
;;;193      /* Clear frequency FREQ[5:0] bits */
;;;194      tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
00000a  f020063f          BIC      r6,r0,#0x3f
;;;195      /* Get pclk1 frequency value */
;;;196      RCC_GetClocksFreq(&rcc_clocks);
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       RCC_GetClocksFreq
;;;197      pclk1 = rcc_clocks.PCLK1_Frequency;
;;;198      /* Set frequency bits depending on pclk1 value */
;;;199      freqrange = (uint16_t)(pclk1 / 1000000);
000014  4928              LDR      r1,|L21.184|
000016  9802              LDR      r0,[sp,#8]
000018  fbb0f1f1          UDIV     r1,r0,r1
00001c  b289              UXTH     r1,r1
;;;200      tmpreg |= freqrange;
00001e  430e              ORRS     r6,r6,r1
;;;201      /* Write to I2Cx CR2 */
;;;202      I2Cx->CR2 = tmpreg;
000020  6066              STR      r6,[r4,#4]
;;;203    
;;;204    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;205      /* Disable the selected I2C peripheral to configure TRISE */
;;;206      I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000022  6822              LDR      r2,[r4,#0]
000024  f64f73fe          MOV      r3,#0xfffe
000028  401a              ANDS     r2,r2,r3
00002a  6022              STR      r2,[r4,#0]
;;;207      /* Reset tmpreg value */
;;;208      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;209      tmpreg = 0;
;;;210    
;;;211      /* Configure speed in standard mode */
;;;212      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
00002c  4b23              LDR      r3,|L21.188|
00002e  682a              LDR      r2,[r5,#0]
000030  429a              CMP      r2,r3
000032  d808              BHI      |L21.70|
;;;213      {
;;;214        /* Standard mode speed calculate */
;;;215        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000034  0052              LSLS     r2,r2,#1
000036  fbb0f0f2          UDIV     r0,r0,r2
00003a  b280              UXTH     r0,r0
;;;216        /* Test if CCR value is under 0x4*/
;;;217        if (result < 0x04)
00003c  2804              CMP      r0,#4
00003e  d200              BCS      |L21.66|
;;;218        {
;;;219          /* Set minimum allowed value */
;;;220          result = 0x04;  
000040  2004              MOVS     r0,#4
                  |L21.66|
000042  1c49              ADDS     r1,r1,#1
;;;221        }
;;;222        /* Set speed value for standard mode */
;;;223        tmpreg |= result;	  
;;;224        /* Set Maximum Rise Time for standard mode */
;;;225        I2Cx->TRISE = freqrange + 1; 
000044  e023              B        |L21.142|
                  |L21.70|
;;;226      }
;;;227      /* Configure speed in fast mode */
;;;228      /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
;;;229         input clock) must be a multiple of 10 MHz */
;;;230      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;231      {
;;;232        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
000046  88eb              LDRH     r3,[r5,#6]
000048  f5a3463f          SUB      r6,r3,#0xbf00
00004c  3eff              SUBS     r6,r6,#0xff
00004e  d00b              BEQ      |L21.104|
;;;233        {
;;;234          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;235          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
;;;236        }
;;;237        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;238        {
;;;239          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;240          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
000050  eb0203c2          ADD      r3,r2,r2,LSL #3
000054  eb031202          ADD      r2,r3,r2,LSL #4
000058  fbb0f0f2          UDIV     r0,r0,r2
00005c  b280              UXTH     r0,r0
;;;241          /* Set DUTY bit */
;;;242          result |= I2C_DutyCycle_16_9;
00005e  f4404080          ORR      r0,r0,#0x4000
                  |L21.98|
;;;243        }
;;;244    
;;;245        /* Test if CCR value is under 0x1*/
;;;246        if ((result & I2C_CCR_CCR) == 0)
000062  0502              LSLS     r2,r0,#20
000064  d006              BEQ      |L21.116|
000066  e007              B        |L21.120|
                  |L21.104|
000068  eb020242          ADD      r2,r2,r2,LSL #1       ;235
00006c  fbb0f0f2          UDIV     r0,r0,r2              ;235
000070  b280              UXTH     r0,r0                 ;235
000072  e7f6              B        |L21.98|
                  |L21.116|
;;;247        {
;;;248          /* Set minimum allowed value */
;;;249          result |= (uint16_t)0x0001;  
000074  f0400001          ORR      r0,r0,#1
                  |L21.120|
;;;250        }
;;;251        /* Set speed value and set F/S bit for fast mode */
;;;252        tmpreg |= (uint16_t)(result | I2C_CCR_FS);
;;;253        /* Set Maximum Rise Time for fast mode */
;;;254        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
000078  f44f7296          MOV      r2,#0x12c
00007c  4351              MULS     r1,r2,r1
00007e  f44f727a          MOV      r2,#0x3e8
000082  fbb1f1f2          UDIV     r1,r1,r2
000086  1c49              ADDS     r1,r1,#1
000088  f4404000          ORR      r0,r0,#0x8000         ;252
00008c  b289              UXTH     r1,r1
                  |L21.142|
00008e  6221              STR      r1,[r4,#0x20]
;;;255      }
;;;256    
;;;257      /* Write to I2Cx CCR */
;;;258      I2Cx->CCR = tmpreg;
000090  61e0              STR      r0,[r4,#0x1c]
;;;259      /* Enable the selected I2C peripheral */
;;;260      I2Cx->CR1 |= I2C_CR1_PE;
000092  6820              LDR      r0,[r4,#0]
000094  f0400001          ORR      r0,r0,#1
000098  6020              STR      r0,[r4,#0]
;;;261    
;;;262    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;263      /* Get the I2Cx CR1 value */
;;;264      tmpreg = I2Cx->CR1;
00009a  6820              LDR      r0,[r4,#0]
;;;265      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;266      tmpreg &= CR1_CLEAR_MASK;
00009c  f64f31f5          MOV      r1,#0xfbf5
0000a0  b280              UXTH     r0,r0                 ;264
0000a2  4008              ANDS     r0,r0,r1
;;;267      /* Configure I2Cx: mode and acknowledgement */
;;;268      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;269      /* Set ACK bit according to I2C_Ack value */
;;;270      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
0000a4  88a9              LDRH     r1,[r5,#4]
0000a6  896a              LDRH     r2,[r5,#0xa]
0000a8  4311              ORRS     r1,r1,r2
0000aa  4301              ORRS     r1,r1,r0
;;;271      /* Write to I2Cx CR1 */
;;;272      I2Cx->CR1 = tmpreg;
0000ac  6021              STR      r1,[r4,#0]
;;;273    
;;;274    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;275      /* Set I2Cx Own Address1 and acknowledged address */
;;;276      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
0000ae  89a8              LDRH     r0,[r5,#0xc]
0000b0  8929              LDRH     r1,[r5,#8]
0000b2  4308              ORRS     r0,r0,r1
0000b4  60a0              STR      r0,[r4,#8]
;;;277    }
0000b6  bd7f              POP      {r0-r6,pc}
;;;278    
                          ENDP

                  |L21.184|
                          DCD      0x000f4240
                  |L21.188|
                          DCD      0x000186a0

                          AREA ||i.I2C_NACKPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_NACKPositionConfig PROC
;;;598      */
;;;599    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;600    {
;;;601      /* Check the parameters */
;;;602      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;603      //assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
;;;604      
;;;605      /* Check the input parameter */
;;;606      if (I2C_NACKPosition == I2C_NACKPosition_Next)
;;;607      {
;;;608        /* Next byte in shift register is the last received byte */
;;;609        I2Cx->CR1 |= I2C_NACKPosition_Next;
;;;610      }
;;;611      else
;;;612      {
;;;613        /* Current byte in shift register is the last received byte */
;;;614        I2Cx->CR1 &= I2C_NACKPosition_Current;
000004  6801              LDR      r1,[r0,#0]
000006  d004              BEQ      |L22.18|
000008  f24f72ff          MOV      r2,#0xf7ff
00000c  4011              ANDS     r1,r1,r2
                  |L22.14|
00000e  6001              STR      r1,[r0,#0]            ;609
;;;615      }
;;;616    }
000010  4770              BX       lr
                  |L22.18|
000012  f4416100          ORR      r1,r1,#0x800          ;609
000016  e7fa              B        |L22.14|
;;;617    
                          ENDP


                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;433      */
;;;434    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  68c2              LDR      r2,[r0,#0xc]
;;;435    {
;;;436      uint16_t tmpreg = 0;
;;;437    
;;;438      /* Check the parameters */
;;;439      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;440    
;;;441      /* Get the old register value */
;;;442      tmpreg = I2Cx->OAR2;
;;;443    
;;;444      /* Reset I2Cx Own address2 bit [7:1] */
;;;445      tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
;;;446    
;;;447      /* Set I2Cx Own address2 */
;;;448      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
000002  f00101fe          AND      r1,r1,#0xfe
000006  b292              UXTH     r2,r2                 ;442
000008  f02202fe          BIC      r2,r2,#0xfe           ;445
00000c  4311              ORRS     r1,r1,r2
;;;449    
;;;450      /* Store the new register value */
;;;451      I2Cx->OAR2 = tmpreg;
00000e  60c1              STR      r1,[r0,#0xc]
;;;452    }
000010  4770              BX       lr
;;;453    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;763      */
;;;764    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;765    {
;;;766      /* Check the parameters */
;;;767      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;768      //assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;769      if (I2C_PECPosition == I2C_PECPosition_Next)
;;;770      {
;;;771        /* Next byte in shift register is PEC */
;;;772        I2Cx->CR1 |= I2C_PECPosition_Next;
;;;773      }
;;;774      else
;;;775      {
;;;776        /* Current byte in shift register is PEC */
;;;777        I2Cx->CR1 &= I2C_PECPosition_Current;
000004  6801              LDR      r1,[r0,#0]
000006  d004              BEQ      |L24.18|
000008  f24f72ff          MOV      r2,#0xf7ff
00000c  4011              ANDS     r1,r1,r2
                  |L24.14|
00000e  6001              STR      r1,[r0,#0]            ;772
;;;778      }
;;;779    }
000010  4770              BX       lr
                  |L24.18|
000012  f4416100          ORR      r1,r1,#0x800          ;772
000016  e7fa              B        |L24.14|
;;;780    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;1004     */
;;;1005   uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  b508              PUSH     {r3,lr}
;;;1006   {
;;;1007     __IO uint32_t tmp = 0;
;;;1008   
;;;1009     /* Check the parameters */
;;;1010     //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1011     //assert_param(IS_I2C_REGISTER(I2C_Register));
;;;1012   
;;;1013     tmp = (uint32_t) I2Cx;
;;;1014     tmp += I2C_Register;
000002  4408              ADD      r0,r0,r1
;;;1015   
;;;1016     /* Return the selected register value */
;;;1017     return (*(__IO uint16_t *) tmp);
000004  9000              STR      r0,[sp,#0]
000006  8800              LDRH     r0,[r0,#0]
;;;1018   }
000008  bd08              POP      {r3,pc}
;;;1019   
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;701      */
;;;702    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  6900              LDR      r0,[r0,#0x10]
;;;703    {
;;;704      /* Check the parameters */
;;;705      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;706      /* Return the data in the DR register */
;;;707      return (uint8_t)I2Cx->DR;
000002  b2c0              UXTB     r0,r0
;;;708    }
000004  4770              BX       lr
;;;709    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;626      */
;;;627    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;628    {
;;;629      /* Check the parameters */
;;;630      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;631      //assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;632      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
;;;633      {
;;;634        /* Drive the SMBusAlert pin Low */
;;;635        I2Cx->CR1 |= I2C_SMBusAlert_Low;
;;;636      }
;;;637      else
;;;638      {
;;;639        /* Drive the SMBusAlert pin High  */
;;;640        I2Cx->CR1 &= I2C_SMBusAlert_High;
000004  6801              LDR      r1,[r0,#0]
000006  d004              BEQ      |L27.18|
000008  f64d72ff          MOV      r2,#0xdfff
00000c  4011              ANDS     r1,r1,r2
                  |L27.14|
00000e  6001              STR      r1,[r0,#0]            ;635
;;;641      }
;;;642    }
000010  4770              BX       lr
                  |L27.18|
000012  f4415100          ORR      r1,r1,#0x2000         ;635
000016  e7fa              B        |L27.14|
;;;643    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;383      */
;;;384    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b112              CBZ      r2,|L28.8|
;;;385    {
;;;386      /* Check the parameters */
;;;387      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;388      //assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;389      /* Test on the direction to set/reset the read/write bit */
;;;390      if (I2C_Direction != I2C_Direction_Transmitter)
;;;391      {
;;;392        /* Set the address bit0 for read */
;;;393        Address |= I2C_OAR1_ADD0;
000002  f0410101          ORR      r1,r1,#1
000006  e001              B        |L28.12|
                  |L28.8|
;;;394      }
;;;395      else
;;;396      {
;;;397        /* Reset the address bit0 for write */
;;;398        Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
000008  f00101fe          AND      r1,r1,#0xfe
                  |L28.12|
;;;399      }
;;;400      /* Send the address */
;;;401      I2Cx->DR = Address;
00000c  6101              STR      r1,[r0,#0x10]
;;;402    }
00000e  4770              BX       lr
;;;403    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;688      */
;;;689    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  6101              STR      r1,[r0,#0x10]
;;;690    {
;;;691      /* Check the parameters */
;;;692      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;693      /* Write in the DR register the data to be sent */
;;;694      I2Cx->DR = Data;
;;;695    }
000002  4770              BX       lr
;;;696    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;510      */
;;;511    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;512    {
;;;513      /* Check the parameters */
;;;514      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;515      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;516      if (NewState != DISABLE)
;;;517      {
;;;518        /* Peripheral under reset */
;;;519        I2Cx->CR1 |= I2C_CR1_SWRST;
;;;520      }
;;;521      else
;;;522      {
;;;523        /* Peripheral not under reset */
;;;524        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L30.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;519
00000a  e001              B        |L30.16|
                  |L30.12|
00000c  f3c1010e          UBFX     r1,r1,#0,#15
                  |L30.16|
000010  6001              STR      r1,[r0,#0]            ;519
;;;525      }
;;;526    }
000012  4770              BX       lr
;;;527    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;534      */
;;;535    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;536    {
;;;537      /* Check the parameters */
;;;538      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;539      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;540      if (NewState == DISABLE)
;;;541      {
;;;542        /* Enable the selected I2C Clock stretching */
;;;543        I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
;;;544      }
;;;545      else
;;;546      {
;;;547        /* Disable the selected I2C Clock stretching */
;;;548        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
000002  6801              LDR      r1,[r0,#0]
000004  d004              BEQ      |L31.16|
000006  f64f727f          MOV      r2,#0xff7f
00000a  4011              ANDS     r1,r1,r2
                  |L31.12|
00000c  6001              STR      r1,[r0,#0]            ;543
;;;549      }
;;;550    }
00000e  4770              BX       lr
                  |L31.16|
000010  f0410180          ORR      r1,r1,#0x80           ;543
000014  e7fa              B        |L31.12|
;;;551    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;283      */
;;;284    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;285    {
;;;286    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;287      /* initialize the I2C_ClockSpeed member */
;;;288      I2C_InitStruct->I2C_ClockSpeed = 5000;
;;;289      /* Initialize the I2C_Mode member */
;;;290      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;291      /* Initialize the I2C_DutyCycle member */
;;;292      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b72ff          MOV      r2,#0xbfff
00000e  80c2              STRH     r2,[r0,#6]
;;;293      /* Initialize the I2C_OwnAddress1 member */
;;;294      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  8101              STRH     r1,[r0,#8]
;;;295      /* Initialize the I2C_Ack member */
;;;296      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000012  8141              STRH     r1,[r0,#0xa]
;;;297      /* Initialize the I2C_AcknowledgedAddress member */
;;;298      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000014  f44f4180          MOV      r1,#0x4000
000018  8181              STRH     r1,[r0,#0xc]
;;;299    }
00001a  4770              BX       lr
;;;300    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;732      */
;;;733    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;734    {
;;;735      /* Check the parameters */
;;;736      //assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;737      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;738      if (NewState != DISABLE)
;;;739      {
;;;740        /* Enable the selected I2C PEC transmission */
;;;741        I2Cx->CR1 |= I2C_CR1_PEC;
;;;742      }
;;;743      else
;;;744      {
;;;745        /* Disable the selected I2C PEC transmission */
;;;746        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L33.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;741
00000a  e002              B        |L33.18|
                  |L33.12|
00000c  f64e72ff          MOV      r2,#0xefff
000010  4011              ANDS     r1,r1,r2
                  |L33.18|
000012  6001              STR      r1,[r0,#0]            ;741
;;;747      }
;;;748    }
000014  4770              BX       lr
;;;749    
                          ENDP


;*** Start embedded assembler ***

#line 1 "drivers\\stm32f4xx_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REV16|
#line 208 "c:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.8.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___15_stm32f4xx_i2c_c_7174d409____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REVSH|
#line 223
|__asm___15_stm32f4xx_i2c_c_7174d409____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____RRX|
#line 410
|__asm___15_stm32f4xx_i2c_c_7174d409____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
